# 27章　アノテーション

## 27.1 アノテーションを使う理由

* プログラムの用途の一部
    1. Scaladocなどのドキュメントの自動生成
    2. 好みのスタイルに合わせたコードの出力
    3. ファイルをオープンしながら，クローズしない場合があるなど，良くあるエラーのチェック
    4. 副作用の管理や所有者プロパティの確認などを目的とした実験的な型チェック

この主のツールを，他のプログラムを入力とするプログラムということでメタプログラミングと呼ぶ．
アノテーションは，ソースコード全体にそれらのツール用の疑似命令を埋め込めるようにして，ツールをサポートする．

* アノテーションによる改善
    1. ドキュメントジェネレータには，一部のメソッドを「使わない方が良いもの」として記述するように指示できる
    2. 出力整形プログラムには，手作業でていねいに整形して，ある部分を処理しないように指示できる
    3. クローズされていないファイルのチェックプログラムには，クローズされていることを別途確認してあるファイルを無視するよう指示できる
    4. 副作用チェッカーには，指定されたメソッドに副作用がないことを確かめるように指示できる

Scalaにおいてはこのような機能を提供するために，最小限のサポートとしてアノテーションという１つの機能が組み込まれている．
アノテーションの意味についてコンパイラは手を付けない．
メタプログラミングツールがそれぞれ自分専用のアノテーションを定義して使うことができる．


## 27.2 アノテーションの構文
アノテーションの例を挙げる．

```
@deprecated def bigMistake() = {...} //...
```

あまりにひどいコードなので将来的に削除される.
他に，val, var, def, class, object, trait, typeの宣言及び定義にアノテーションをつけられる．

アノテーションは式にも適用できる．式の後にコロンを入れてさらにアノテーションを書く．
構文的には型として使われているように見える．

```
(e: @unchecked) match {
  // 徹底的なチェックは不要なケース
}
```

また．アノテーションは型にも適用できる．(後述)

### アノテーションの一般系
```
@<アノテーション> (<式1>, <式2>,....)
```

<アノテーション>にはアノテーションのクラスを指定する．
<式>の部分はアノテーションに対する引数である．
引数を必要としないアノテーションでは()を省略可能だが書いても良い．

アノテーションに与える引数の正確な形はアノテーションクラスごとに異なる．
ほとんどのアノテーションプロセッサーは123や"abc"のようなイミディエート定数(即値)だけを指定できるようにしている．
しかしコンパイラ自体は型チェックを満たす式をサポートする．
```
@cool val normal = "Hello"
@coolerThan(normal) val fonzy = "Heeyyy"
```

Scala内部ではアノテーションクラスのコンストラクタ呼び出しという形でアノテーションを表現している．
@ をnewに置き換えれば有効なインスタンス生成式になる．
引数に他のアノテーションを取るようなアノテーションの場合は，
アノテーションは有効な式ではないため@ ではなくnewを用いる．

```
scala> import annotation._
import annotation._

scala> class strategy(arg: Annotation) extends Annotation
defined class strategy

scala> class delayed extends Annotation
defined class delayed

scala> @strategy(@delayed) def f(){}
<console>:1: error: illegal start of simple expression
       @strategy(@delayed) def f(){}
                 ^

scala> @strategy(new delayed) def f(){}
f: ()Unit
```

## 27.3 標準アノテーション
### 27.3.1 使うべきでない機能の指定
一度書いてしまったコードでも，後からやめておけば良かったと思う場合がある．
しかし誰かが使っている場合があるのでいきなり消すわけにも行かない．
そんな時に，deprecatedアノテーションを使って，将来削除予定の不適切なクラスの使用を知らせるようにする．

```
@deprecated def bigMistake() = // ...
```

引数に文字列を指定すると，その文字列がエラーメッセージとともに出力される．
このメッセージを使って，使うべきでないメソッドの代わりに何を使うべきかを開発者に示すことができる．

```
@deprecated("use newShinyMethod() instead")
def bigMistake() = // ....
```

表示されるメッセージは次のようになる．

```
$ scalac -deprecation Deprecation2.scala
Deprecation2.scala:33: warning: method bigMistake in object
Deprecation2 is deprecated: use new ShinyMethod() instead
    bigMistake()
    ^
one warning found
```

### 27.3.2 「揮発性」フィールド
平行プログラミングでは共有されたミュータブルな状態情報と相性が悪いため，
Scalaではメッセージ交換に重点を置いている．
それでもミュータブルな状態を使いたい場合に@volatileアノテーションを使う．

このアノテーションは適用されている変数が複数のスレッドから使われるものだということをコンパイラに知らせる．
Javaプラットフォーム上ではJavaコードでフィールドを書き，Javaのvolatile修飾子をつけたのと同じ動作が得られる．

cf.
http://java-code.jp/124

http://www.ibm.com/developerworks/jp/java/library/j-jtp06197.html

### 27.3.3 バイナリーシリアライゼーション
シリアライゼーションフレームワークはオブジェクトとバイトストリームの間の相互変換を助ける．
オブジェクトをディスクに保存したい，ネットワーク越しに送信したいという場合に役立つ．

Scalaは独自のシリアライゼーションプラットフォームを持っておらず，土台のプラットフォームが提供しているフレームワークを使わなければならない．
Scalaはそのために様々なフレームワークで役立つ3種類のアノテーションを提供している．

1. @serializable
    * クラスがそもそもシリアライズできるかどうかを示す．
    * ソケットやGUIウィンドウのハンドルはシリアライズできない．
2. @SerialVersionUID
    * シリアライズできるクラスの書き換えに対応
    * シリアル番号を与えることで，後でバイトストリームを再ロードしてオブジェクトに変換しようとしたときにクラスの現在のバージョンとバイトストリームのバージョンが一致するかチェックできる．
    * シリアライズ上非互換な変更をクラスに加える場合はバージョン番号を変更する．
3. @transient
    * シリアライズすべきでないフィールドにつける
    * @transient 付きのフィールドを含むオブジェクトをシリアライズする時，マーク付きのフィールドはシリアライズしない．
    * ロード時にはその型のデフォルト値が与えられる

### 27.3.4 get / set メソッドの自動生成
Scalaではフィールドアクセスとメソッド呼び出しの構文をブレンドしているのでフィールドのget/setメソッドを明示的に書く必要はない．
しかしプラットフォーム固有フレームワークの中にはget/setメソッドを必要とするものがある．
このような場合のために，@scala.reflect.BeanPropertyアノテーションが用意されている，
フィールドにこのアノテーションをつけると，コンパイラが自動でget/setメソッドを用意してくれる．

### 27.3.5 末尾再帰
一般に，末尾再帰にする必要のあるメソッドには@tailrecアノテーションを追加する．
例えば末尾再帰にしなければ非常に深く再帰してしまうような場合．

末尾再帰によるメソッドの最適化をScalaコンパイラに指示したいときは，メソッド定義の前に@tailrecを追加する．
できない場合は理由とエラーメッセージが表示される．

### 27.3.6 パターンのチェック回避
@unchecked アノテーションはコンパイラがパターンマッチ中に解釈する．
マッチ式に抜けているケースがあるように見えても，エラーをださないように指示する．

### 27.3.7 ネイティブメソッド
@native アノテーションは，メソッドの実装がScalaコードではなくランタイムによって提供されることをコンパイラに知らせる．

```
@native
def beginCountdown() {}
```
